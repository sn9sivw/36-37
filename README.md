# 36-37
1. Какие критерии используются для оценки качества алгоритмов?
Для оценки качества алгоритмов чаще всего применяются следующие основные критерии:

Асимптотическая сложность — показывает, насколько быстро растет время выполнения алгоритма при увеличении размера входных данных. Это один из важнейших критериев эффективности алгоритма.
Потребляемая память — сколько памяти требует алгоритм для своей работы. Важно учитывать, особенно когда речь идет о больших объемах данных.
Простота реализации — насколько легко алгоритм реализовать на практике.
Стабильность — степень устойчивости алгоритма к различным видам входных данных, включая краевые случаи.
Гибкость — возможность адаптации алгоритма к разным типам задач и модификациям.
Масштабируемость — способность алгоритма эффективно справляться с большими объемами данных.
Параллелизуемость — возможность разбиения алгоритма на независимые части для параллельного выполнения.
2. Почему скорость работы алгоритма оценивается не временем выполнения, а количеством элементарных операций?
Время выполнения зависит от множества факторов: мощности процессора, архитектуры системы, компилятора и даже состояния операционной системы. Оно также сильно варьируется между разными машинами. Поэтому оценить абсолютное время работы сложно и непрактично.

Однако количество элементарных операций (например, сравнений, присваиваний, арифметических действий) остается неизменным независимо от оборудования. Это позволяет сравнивать алгоритмы абстрактно, независимо от конкретной среды исполнения. Такой подход называется асимптотическим анализом, который измеряет поведение алгоритма относительно размера входных данных.

3. Как учитывается размер данных при оценке скорости алгоритма?
Размер данных напрямую влияет на оценку сложности алгоритма. В асимптотическом анализе мы используем обозначения вроде 
O
(
f
(
n
)
)
O(f(n)), где 
f
(
n
)
f(n) — функция, зависящая от размера входных данных (
n
n). Например:

O
(
1
)
O(1) означает, что время выполнения не зависит от количества элементов,
O
(
n
)
O(n) — линейная зависимость (время пропорционально количеству элементов),
O
(
n
2
)
O(n 
2
 ) — квадратичная зависимость (для каждого элемента выполняются операции над всеми остальными элементами).
Таким образом, чем больше данных, тем сильнее проявляется влияние функции 
f
(
n
)
f(n).

4. Что означают записи 
O
(
1
)
O(1), 
O
(
n
)
O(n), 
O
(
n
2
)
O(n 
2
 ) и 
O
(
2
n
)
O(2 
n
 )?
O
(
1
)
O(1): Постоянный временной показатель. Алгоритм выполняется за фиксированное время вне зависимости от объема данных. Пример: доступ к элементу массива по индексу.
O
(
n
)
O(n): Линейный временной показатель. Время выполнения прямо пропорционально размеру входных данных. Пример: последовательный проход по массиву.
O
(
n
2
)
O(n 
2
 ): Квадратичный временной показатель. Обычно возникает в алгоритмах, где происходит вложенный цикл. Пример: сортировка пузырьком.
O
(
2
n
)
O(2 
n
 ): Экспоненциальный временной показатель. Очень неэффективные алгоритмы, часто встречающиеся в рекурсивных задачах типа переборов всех возможных вариантов. Пример: задача о рюкзаке.
5. В каких случаях алгоритм, имеющий асимптотическую сложность 
O
(
n
2
)
O(n 
2
 ), может работать быстрее, чем алгоритм с асимптотической сложностью 
O
(
n
)
O(n)?
Алгоритмы с большей асимптотической сложностью иногда работают быстрее на небольших объемах данных благодаря меньшей константе перед функцией роста.

Рассмотрим пример:

Пусть у нас есть два алгоритма: 
A
1
A 
1
​
  с временной сложностью 
O
(
n
)
O(n) и 
A
2
A 
2
​
  с временной сложностью 
O
(
n
2
)
O(n 
2
 ).
Допустим, 
A
1
A 
1
​
  работает как 
T
1
=
c
1
n
T 
1
​
 =c 
1
​
 n, а 
A
2
A 
2
​
  работает как 
T
2
=
c
2
n
2
T 
2
​
 =c 
2
​
 n 
2
 .
Если константа 
c
1
c 
1
​
  значительно больше 
c
2
c 
2
​
 , то на малых значениях 
n
n алгоритм 
A
2
A 
2
​
  может выполняться быстрее, несмотря на худшую асимптотику.
Пример: Сортировка вставками (
O
(
n
2
)
O(n 
2
 )), которая на маленьких массивах может оказаться быстрее быстрой сортировки (
O
(
n
log
⁡
n
)
O(nlogn)).
# par 37
1. Зачем нужно доказывать правильность программ?
Доказательство правильности программ важно потому, что оно гарантирует, что программа делает именно то, что ожидается от неё. Это особенно критично для программ, связанных с безопасностью, финансовыми операциями, управлением производственными процессами и медицинскими системами. Ошибки в коде могут привести к серьёзным последствиям, таким как финансовые потери, аварии или угрозы жизни людей.

Основные причины доказательства корректности:
Повышение надёжности. Чем больше уверенность в корректности программы, тем меньше вероятность сбоев.
Предсказуемое поведение. Доказательства позволяют убедиться, что программа ведёт себя ожидаемо во всех возможных сценариях.
Безопасность. Особенно актуально для систем, работающих в условиях высокого риска (авиация, атомная энергетика и др.).
Минимизация затрат на тестирование. Хотя тестирование помогает выявить ошибки, оно не всегда покрывает все возможные сценарии.
2. Расскажите о двух подходах к проверке правильности программ.
Существует несколько подходов к проверке корректности программ. Вот два основных:

a) Формальная верификация
Это строгий математический метод проверки программы. Здесь используются аксиомы и теоремы для доказательства соответствия программы её спецификации. Этот подход применяется там, где крайне важна надёжность (например, авионика, медицинские устройства).

Процесс включает:

Создание спецификаций (что должна делать программа);
Построение модели программы;
Использование автоматических инструментов для доказательства корректности.
b) Тестирование
Тестирование заключается в выполнении программы с различными наборами входных данных и сравнении результатов с ожидаемой спецификацией. Это практический способ проверки корректности, хотя он имеет ограничения (см. следующий пункт).

Основные виды тестирования:

Модульное тестирование (каждый модуль проверяется отдельно);
Интеграционное тестирование (модули тестируются вместе);
Регрессионное тестирование (повторное тестирование после изменений).
3. Почему с помощью тестирования сложно доказать правильность программы? В каких случаях это всё же можно сделать? Приведите примеры.
Тестирование не всегда способно охватить все возможные варианты поведения программы. Даже если программа прошла через тысячи тестов, остаётся риск пропустить какой-то специфический случай, который приведёт к ошибке. Однако тестирование остаётся важным инструментом, особенно в сочетании с другими методами.

Ограничения тестирования:
Невозможно протестировать все возможные комбинации входных данных.
Тестирование не выявляет логические ошибки, если они возникают редко.
Сложные программы могут иметь огромное количество состояний, которые невозможно проверить исчерпывающе.
Когда тестирование достаточно:
Для простых программ с небольшим числом входных параметров и чётко определёнными результатами.
В комбинациях с другими методами, такими как статический анализ или формальные методы.
Примеры:
Простые калькуляторы или небольшие утилиты, где проверка всех граничных случаев возможна.
Программы, работающие с ограниченным набором данных (например, вычисление суммы чисел от 1 до 100).
4. Что изменится в доказательстве алгоритма Евклида, если тип данных — это произвольные натуральные числа (неравенство m > n может не выполняться)?
Алгоритм Евклида находит наибольший общий делитель (НОД) двух целых чисел. Традиционно предполагается, что одно число больше другого, чтобы упростить проверку условия завершения. Но если допустить, что числа могут быть равны или второе число может быть больше первого, потребуется изменить алгоритм следующим образом:

Добавить проверку порядка чисел: если 
m
<
n
m<n, поменять их местами.
Это сохранит основную идею алгоритма, но позволит избежать ошибок, связанных с неправильной инициализацией.
Изменится ли само доказательство? Да, немного. Нужно будет учесть симметричность НОД и добавить дополнительную проверку порядка чисел. В остальном доказательство останется прежним.

5. Что такое инвариант цикла?
Инвариант цикла — это утверждение, которое остаётся истинным на каждой итерации цикла. Инварианты помогают гарантировать, что цикл завершится правильно и достигнет нужного результата.

Пример:
Пусть цикл ищет минимальный элемент в массиве:


min_value = array[0]
for i in range(1, len(array)):
    if array[i] < min_value:
        min_value = array[i]
Здесь инвариантом является утверждение: min_value содержит наименьший элемент среди уже проверенных значений массива.

6. Зачем нужно определять инвариант цикла?
Определение инварианта цикла помогает:

Убедиться, что цикл достигает правильного результата.
Проверять корректность работы цикла на каждом шаге.
Упрощать понимание сложной логики цикла.
Без инвариантов сложно доказать, что цикл выполняет свою функцию корректно, особенно в сложных программах.

7. Что такое спецификация? Почему желательно формулировать её в виде формальных утверждений, а не на естественном языке?
Спецификация — это описание требований к программе, указывающее, какие результаты она должна выдавать при различных входных данных. Она определяет границы поведения программы.

Формализация спецификаций необходима для:

Точности. Естественный язык допускает двусмысленности, тогда как формальные утверждения однозначны.
Проверяемости. Формализованные спецификации легче проверять автоматически.
Автоматизации. Многие инструменты анализа и верификации требуют формальной спецификации.
Примером формального утверждения может служить предусловие и постусловие для функции.
Запись (QSR) обозначает три важных аспекта в контексте разработки программного обеспечения и управления проектами: качество (Quality), стоимость (Cost) и сроки (Schedule). Эти три параметра являются ключевыми факторами успеха любого проекта, и баланс между ними часто называют треугольником ограничений (или тройственной ограниченностью).
Качество (Quality) — уровень функциональности, надежности и удобства использования продукта или услуги. Высокое качество требует большего внимания к деталям и тестированию, что может увеличивать затраты и сроки.
Стоимость (Cost) — сумма ресурсов, необходимых для выполнения проекта, включая трудовые ресурсы, материалы и оборудование. Снижение стоимости может негативно сказаться на качестве или сроках.
Сроки (Schedule) — временные рамки, отведенные на выполнение проекта. Сокращение сроков может потребовать увеличения затрат или снижения качества.
Коррекция — это процесс исправления ошибок или внесения изменений в уже существующую систему (например, программу), чтобы она соответствовала заданным требованиям или стандартам. В контексте программирования, коррекция часто связана с устранением багов или улучшением производительности программы.

Корректность программы
Корректная программа — это программа, которая работает согласно своему назначению и спецификациям, обеспечивая правильные результаты на всех допустимых входных данных. Однако, если программа "зависает" при неверных входных данных, это может указывать на проблему с обработкой исключений или проверкой ввода.

Обсуждение вопроса в классе:

Понятие корректности: Корректность подразумевает, что программа должна обрабатывать все возможные случаи ввода, включая ошибочные данные.
Обработка ошибок: Программа должна предусматривать механизмы обработки ошибок, такие как вывод сообщений об ошибке или возврат в исходное состояние.
Тестирование: Важно проводить тестирование программы на различных наборах данных, включая граничные и аномальные значения.
Производительность: "Зависание" программы может негативно сказаться на её производительности и удобстве использования.
Реакция на ошибки: Студенты могут обсудить различные подходы к обработке ошибок: игнорирование, сообщение пользователю, восстановление состояния программы.
Примеры: Можно привести реальные примеры программ, которые хорошо справляются с ошибочными данными, и тех, которые "зависают".
Практическое задание: Преподаватель может предложить студентам написать простую программу, обрабатывающую вводимые данные, и проверить её поведение на разных типах входных значений.
Верификация программы
Верификация программы — это процесс проверки соответствия программы её спецификациям и требованиям. Она включает в себя анализ кода, тестирование и другие методы для подтверждения правильности работы программы. Верификация помогает убедиться, что программа делает именно то, что от неё ожидается, и соответствует установленным стандартам качества.


Доказательство правильности готовой программы требует тщательного анализа всего кода, начиная с функциональных требований и заканчивая реализацией. Это может быть сложной задачей, особенно для больших и сложных программ, где трудно учесть все возможные сценарии выполнения. Основные трудности включают:

Большое количество возможных путей выполнения программы.
Необходимость учитывать все граничные условия и исключения.
Риск пропуска мелких ошибок, которые могут повлиять на общую функциональность.
Написание программы с доказательством правильности блоков
Написание программы с одновременным доказательством правильности отдельных блоков предполагает использование методологии, такой как структурное программирование или модульный подход. Этот подход позволяет разбивать программу на небольшие, легко управляемые части, каждая из которых имеет свою спецификацию и тестовые случаи. Преимущества такого метода заключаются в следующем:

Упрощение процесса тестирования и отладки благодаря меньшей сложности каждого блока.
Возможность повторного использования проверенных модулей в будущих проектах.
Повышение общей надежности программы за счет снижения вероятности возникновения ошибок.
Однако, даже при таком подходе существуют свои сложности:

Требуется высокий уровень дисциплины и планирования со стороны разработчиков.
Необходимо постоянно поддерживать соответствие между требованиями и кодом.
Возможны проблемы интеграции отдельных блоков в единую систему.
Обсуждение в классе
Для обсуждения данного вопроса в классе можно использовать следующие темы:

Преимущества и недостатки обоих подходов: Попросите студентов поделиться своими мыслями о преимуществах и недостатках каждого подхода.
Опыт реальных проектов: Если возможно, приведите примеры из реальной практики, когда один из подходов оказался более эффективным.
Практические задания: Предложите студентам разработать небольшую программу, используя оба подхода, и сравнить результаты.
Инструменты и методики: Обсудите существующие инструменты и методики, которые помогают в процессе доказательства правильности программ.
Таким образом, выбор подхода зависит от конкретных условий проекта, уровня квалификации команды и требований к надежности программного продукта.


